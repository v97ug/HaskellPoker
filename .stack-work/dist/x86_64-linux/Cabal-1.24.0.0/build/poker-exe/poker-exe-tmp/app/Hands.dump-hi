
==================== FINAL INTERFACE ====================
2016-10-30 12:16:47.341927 UTC

interface main@main:Hands 8001
  interface hash: 8b828f92baf819ea8887dac8a0b906b0
  ABI hash: cd7563afb27d6b24f8ddc7c449f05715
  export-list hash: 63321d20311ea0ecbb141c4c4193f529
  orphan hash: 23c9b2f6b04aa6b6015f5a4b8b021e33
  flag hash: b61242a7c40cc421f4902b0c8f33bcb2
  sig of: Nothing
  used TH splices: False
  where
exports:
  Hands.pokerHand
  Hands.toHand
  Hands.Hand{fromHand}
  Hands.PokerHand
module dependencies: Cards
package dependencies: GLFW-b-1.4.8.1@GLFW-b-1.4.8.1-2oLi8d8Om6j90ytPw2you1
                      GLURaw-2.0.0.2@GLURaw-2.0.0.2-CXqiFREEjzx2h5fh9cccgi
                      JuicyPixels-3.2.8@JuicyPixels-3.2.8-9xVAaSn1ptq1f1nvfTAuq3
                      JuicyPixels-util-0.2@JuicyPixels-util-0.2-DLVBsASb875DbzDt8LnQRe
                      ObjectName-1.1.0.1@ObjectName-1.1.0.1-HHHIolNI8Pm5H3OGkgSUrO
                      OpenGL-3.0.1.0@OpenGL-3.0.1.0-L3kgxMgk99dGXu7ugl8pfi
                      OpenGLRaw-3.2.3.0@OpenGLRaw-3.2.3.0-1lEp0meCLgF9BpuYJlcXHY
                      StateVar-1.1.0.4@StateVar-1.1.0.4-CJpWsiXJdd89SnV9dZtTwc
                      adjunctions-4.3@adjunctions-4.3-GCEjqNzETW59DSv4CMOptV
                      array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      base-orphans-0.5.4@base-orphans-0.5.4-5IQvrjd7gNP548VkOOyIq6
                      bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k
                      binary-0.8.3.0@binary-0.8.3.0-C4Tdq516dA2P2jpb0pxQ0
                      bindings-GLFW-3.1.2.2@bindings-GLFW-3.1.2.2-2GG6GK5a2OkK8NpUgT7p3p
                      boundingboxes-0.2.3@boundingboxes-0.2.3-B5Lpk0UgQX9FW4DN0qgVnk
                      bytes-0.15.2@bytes-0.15.2-HP6DsJicUjcLfydsuJ4jcG
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      cereal-0.5.3.0@cereal-0.5.3.0-JAeSmYgm4O6ETcVwWu1cR8
                      colors-0.3.0.2@colors-0.3.0.2-AvkeI2ZeqYcBVc35VrD0W6
                      comonad-5@comonad-5-1X5fCjgjqtUIqJcEv6Bntb
                      containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM
                      contravariant-1.4@contravariant-1.4-9srMvDZNIDHARyPiex7EnJ
                      control-bool-0.2.1@control-bool-0.2.1-Jyyb4EXrMDw8rIK211gyYF
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.2.6.2@directory-1.2.6.2
                      distributive-0.5.0.2@distributive-0.5.0.2-Cdz2vLOk85j1doGXLcictT
                      exceptions-0.8.3@exceptions-0.8.3-7py7fmRxowDFpHmiHGKrTb
                      filepath-1.4.1.0@filepath-1.4.1.0
                      fixed-0.2.1.1@fixed-0.2.1.1-21JkkJmr6h52cZo1o8cauA
                      free-4.12.4@free-4.12.4-BgJ9ci1u1y48vHU0OFcVsx
                      free-game-1.1.90@free-game-1.1.90-Ic1poE82j1wINymiLed5pB
                      freetype2-0.1.1@freetype2-0.1.1-BNzVW0Qm4YZInBL0rkUB7d
                      ghc-boot-th-8.0.1@ghc-boot-th-8.0.1 ghc-prim-0.5.0.0
                      half-0.2.2.3@half-0.2.2.3-BFHx0LiJemg6baNXrjGThF
                      hashable-1.2.4.0@hashable-1.2.4.0-AwGBZwH5NOu32fFT3k5XwG
                      integer-gmp-1.0.0.1
                      kan-extensions-5.0.1@kan-extensions-5.0.1-GsZ3y7l4oBZBdQifYSzpU9
                      lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7
                      linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6
                      mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      prelude-extras-0.4.0.3@prelude-extras-0.4.0.3-FAyB4iuuM7cHXdrLMZtdXq
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.1.0@primitive-0.6.1.0-Ip44DqhfCp21tTUYbecwa
                      profunctors-5.2@profunctors-5.2-8aCFgYqhmEQC00Ujrg8wb
                      random-1.1@random-1.1-54KmMHXjttlERYcr1mvsAe
                      reflection-2.1.2@reflection-2.1.2-J1ZzlxijzaHGRixYxgxlf9
                      scientific-0.3.4.9@scientific-0.3.4.9-6A89ogaqIZMGXcxRrTFA5h
                      semigroupoids-5.1@semigroupoids-5.1-Gg9LyNoAhKN7Lad6MtBCkX
                      stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF
                      tagged-0.8.5@tagged-0.8.5-CtgV6EcN0do8F92i1S6iYx
                      template-haskell-2.11.0.0
                      text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-81lZyuOJOvsD0zyCv2TKld
                      unix-2.7.2.0@unix-2.7.2.0
                      unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-L1VZsahRbVJ1PITZedf9hg
                      vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6
                      zlib-0.6.1.1@zlib-0.6.1.1-4cYT5jyS3jw6zZyCUZMz3T
orphans: GLFW-b-1.4.8.1@GLFW-b-1.4.8.1-2oLi8d8Om6j90ytPw2you1:Graphics.UI.GLFW.Types
         base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0-C4Tdq516dA2P2jpb0pxQ0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         colors-0.3.0.2@colors-0.3.0.2-AvkeI2ZeqYcBVc35VrD0W6:Data.Color
         free-game-1.1.90@free-game-1.1.90-Ic1poE82j1wINymiLed5pB:FreeGame
         free-game-1.1.90@free-game-1.1.90-Ic1poE82j1wINymiLed5pB:FreeGame.Backend.GLFW
         free-game-1.1.90@free-game-1.1.90-Ic1poE82j1wINymiLed5pB:FreeGame.Instances
         hashable-1.2.4.0@hashable-1.2.4.0-AwGBZwH5NOu32fFT3k5XwG:Data.Hashable.Generic
         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.Instances
         reflection-2.1.2@reflection-2.1.2-J1ZzlxijzaHGRixYxgxlf9:Data.Reflection
         stm-2.4.4.1@stm-2.4.4.1-4z2NRWnB0NIIUvSJsHW0kF:Control.Monad.STM
         text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j:Data.Text
         text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Unboxed
family instance modules: GLFW-b-1.4.8.1@GLFW-b-1.4.8.1-2oLi8d8Om6j90ytPw2you1:Graphics.UI.GLFW.Types
                         JuicyPixels-3.2.8@JuicyPixels-3.2.8-9xVAaSn1ptq1f1nvfTAuq3:Codec.Picture.Tga
                         JuicyPixels-3.2.8@JuicyPixels-3.2.8-9xVAaSn1ptq1f1nvfTAuq3:Codec.Picture.Tiff
                         JuicyPixels-3.2.8@JuicyPixels-3.2.8-9xVAaSn1ptq1f1nvfTAuq3:Codec.Picture.Types
                         adjunctions-4.3@adjunctions-4.3-GCEjqNzETW59DSv4CMOptV:Data.Functor.Rep
                         base-4.9.0.0:Control.Applicative base-4.9.0.0:Data.Complex
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Compose
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.Functor.Product base-4.9.0.0:Data.Functor.Sum
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Biff
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Clown
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Flip
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Join
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Joker
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Product
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Sum
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Tannen
                         bifunctors-5.4.1@bifunctors-5.4.1-2CMldPyzyp9LmjO5mJ1j8k:Data.Bifunctor.Wrapped
                         bytes-0.15.2@bytes-0.15.2-HP6DsJicUjcLfydsuJ4jcG:Data.Bytes.Get
                         bytes-0.15.2@bytes-0.15.2-HP6DsJicUjcLfydsuJ4jcG:Data.Bytes.Signed
                         bytes-0.15.2@bytes-0.15.2-HP6DsJicUjcLfydsuJ4jcG:Data.Bytes.VarInt
                         containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1-Ha3qpRxMQ6UJleQLCYcCoM:Data.Set.Base
                         ghc-boot-th-8.0.1@ghc-boot-th-8.0.1:GHC.LanguageExtensions.Type
                         kan-extensions-5.0.1@kan-extensions-5.0.1-GsZ3y7l4oBZBdQifYSzpU9:Data.Functor.Day
                         kan-extensions-5.0.1@kan-extensions-5.0.1-GsZ3y7l4oBZBdQifYSzpU9:Data.Functor.Yoneda
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.At
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.Internal.Indexed
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.Reified
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.Tuple
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.Wrapped
                         lens-4.14@lens-4.14-IJHIu5ECNzmIvypqaucYG7:Control.Lens.Zoom
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.Plucker
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.Quaternion
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V0
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V1
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V2
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V3
                         linear-1.20.5@linear-1.20.5-4kpNUCVxUq2DOGtNJfuat6:Linear.V4
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primitive-0.6.1.0-Ip44DqhfCp21tTUYbecwa:Control.Monad.Primitive
                         profunctors-5.2@profunctors-5.2-8aCFgYqhmEQC00Ujrg8wb:Data.Profunctor.Rep
                         tagged-0.8.5@tagged-0.8.5-CtgV6EcN0do8F92i1S6iYx:Data.Tagged
                         template-haskell-2.11.0.0:Language.Haskell.TH.Syntax
                         text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j:Data.Text
                         text-1.2.2.1@text-1.2.2.1-BbJ8XwxQPYLIiQbtPTWn3j:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-L1VZsahRbVJ1PITZedf9hg:Data.HashMap.Base
                         unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-L1VZsahRbVJ1PITZedf9hg:Data.HashSet
                         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector
                         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Primitive
                         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Storable
                         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Unboxed
                         vector-0.11.0.0@vector-0.11.0.0-BEDZb5o2QOhGbIm6ky7rl6:Data.Vector.Unboxed.Base
                         zlib-0.6.1.1@zlib-0.6.1.1-4cYT5jyS3jw6zZyCUZMz3T:Codec.Compression.Zlib.Stream
import  -/  base-4.9.0.0:Control.Monad 7767aebfd53f0b584cef2fe66ad3986c
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Enum fdf7ac3e1b0be0a4a37257601bddad14
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  Cards 3f7aa1f66656703e987cdd6bd0fbd461
  exports: d1519e401fbcc677cf0d5c58870d86ed
  Card 0c68e2144bde33f5725c7745e2ae21ec
  getNum 592d90629255c689fdd1b86bec3e0f03
  getRank b08de5249aa4fa6cd3e141bfa2dc2288
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand :: GHC.Enum.Enum Hands.PokerHand
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.PokerHand
                  Hands.$fEnumPokerHand_$csucc
                  Hands.$fEnumPokerHand_$cpred
                  Hands.$fEnumPokerHand_$ctoEnum
                  Hands.$fEnumPokerHand_$cfromEnum
                  Hands.$fEnumPokerHand_$cenumFrom
                  Hands.$fEnumPokerHand_$cenumFromThen
                  Hands.$fEnumPokerHand_$cenumFromTo
                  Hands.$fEnumPokerHand_$cenumFromThenTo -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand1 :: GHC.Prim.Int# -> Hands.PokerHand
  {- Arity: 1, Strictness: <L,U>x -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand2 :: Hands.PokerHand
  {- Strictness: x -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand3 :: Hands.PokerHand
  {- Strictness: x -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cenumFrom :: Hands.PokerHand -> [Hands.PokerHand]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Hands.PokerHand) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand a
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 8#) of wild {
                   GHC.Types.False -> Hands.$fEnumPokerHand_go x0
                   GHC.Types.True -> GHC.Types.[] @ Hands.PokerHand }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cenumFromThen ::
    Hands.PokerHand -> Hands.PokerHand -> [Hands.PokerHand]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand a
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand b
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [Hands.PokerHand]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (y :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [Hands.PokerHand]
                            Hands.$fEnumPokerHand_c1
                            (GHC.Types.[] @ Hands.PokerHand)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [Hands.PokerHand]
                            Hands.$fEnumPokerHand_c1
                            (GHC.Types.[] @ Hands.PokerHand)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 8# GHC.Types.True -> $j 0# }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cenumFromThenTo ::
    Hands.PokerHand
    -> Hands.PokerHand -> Hands.PokerHand -> [Hands.PokerHand]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Hands.PokerHand)
                   (x2 :: Hands.PokerHand)
                   (y :: Hands.PokerHand) ->
                 let {
                   x4 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand x1
                 } in
                 let {
                   x5 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x5 x4) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [Hands.PokerHand]
                        Hands.$fEnumPokerHand_c
                        (GHC.Types.[] @ Hands.PokerHand)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Hands.PokerHand y)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [Hands.PokerHand]
                        Hands.$fEnumPokerHand_c
                        (GHC.Types.[] @ Hands.PokerHand)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Hands.PokerHand y) }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cenumFromTo ::
    Hands.PokerHand -> Hands.PokerHand -> [Hands.PokerHand]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Hands.PokerHand) (y :: Hands.PokerHand) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand x
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go5 :: GHC.Prim.Int# -> [Hands.PokerHand]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ Hands.PokerHand
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 0#) of wild1 {
                               GHC.Types.False -> Hands.$fEnumPokerHand1 x1
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x1 8#) of wild2 {
                                    GHC.Types.False -> Hands.$fEnumPokerHand1 x1
                                    GHC.Types.True -> GHC.Prim.tagToEnum# @ Hands.PokerHand x1 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y1) of wild1 {
                               GHC.Types.False -> go5 (GHC.Prim.+# x1 1#)
                               GHC.Types.True -> GHC.Types.[] @ Hands.PokerHand })
                      } in
                      go5 x0
                   GHC.Types.True -> GHC.Types.[] @ Hands.PokerHand }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cfromEnum :: Hands.PokerHand -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ Hands.PokerHand x1) }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$cpred :: Hands.PokerHand -> Hands.PokerHand
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Hands.PokerHand x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Hands.PokerHand (GHC.Prim.+# wild -1#)
                   0# -> Hands.$fEnumPokerHand2 } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$csucc :: Hands.PokerHand -> Hands.PokerHand
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Hands.PokerHand x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Hands.PokerHand (GHC.Prim.+# wild 1#)
                   8# -> Hands.$fEnumPokerHand3 } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_$ctoEnum :: GHC.Types.Int -> Hands.PokerHand
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Hands.$w$ctoEnum ww1 }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_c ::
    GHC.Types.Int -> [Hands.PokerHand] -> [Hands.PokerHand]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Hands.PokerHand]) ->
                 GHC.Types.:
                   @ Hands.PokerHand
                   (Hands.$fEnumPokerHand_$ctoEnum x)
                   ys) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_c1 ::
    GHC.Types.Int -> [Hands.PokerHand] -> [Hands.PokerHand]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Hands.PokerHand]) ->
                 GHC.Types.:
                   @ Hands.PokerHand
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Hands.PokerHand a })
                   ys) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEnumPokerHand_go :: GHC.Prim.Int# -> [Hands.PokerHand]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
36d64dbe2425fd68387689087fcb4672
  $fEqHand :: GHC.Classes.Eq Hands.Hand
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.Hand Hands.$fEqHand_$c== Hands.$fEqHand_$c/= -}
2f76490fa495ccb62e2531eb400980cf
  $fEqHand1 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fEq[]_$c== @ Cards.Card Cards.$fEqCard) -}
36d64dbe2425fd68387689087fcb4672
  $fEqHand_$c/= :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fEqHand_$s$fEq[]_$c/=
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fEqHand_$c== :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                Hands.$fEqHand1
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
b34e7b71fb0b2fe9ad76c1f2ff60053e
  $fEqHand_$s$fEq[]_$c/= ::
    [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 GHC.Classes.not
                   (GHC.Classes.$fEq[]_$c== @ Cards.Card Cards.$fEqCard x y)) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEqPokerHand :: GHC.Classes.Eq Hands.PokerHand
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.PokerHand
                  Hands.$fEqPokerHand_$c==
                  Hands.$fEqPokerHand_$c/= -}
809a7a18918542f71a6511a2ac0dbca3
  $fEqPokerHand_$c/= ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of wild {
                   Hands.HighCards
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.HighCards -> GHC.Types.False }
                   Hands.OnePair
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.OnePair -> GHC.Types.False }
                   Hands.TwoPair
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.TwoPair -> GHC.Types.False }
                   Hands.ThreeCards
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.ThreeCards -> GHC.Types.False }
                   Hands.Straight
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.Straight -> GHC.Types.False }
                   Hands.Flush
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.Flush -> GHC.Types.False }
                   Hands.FullHouse
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.FullHouse -> GHC.Types.False }
                   Hands.FourCards
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Hands.FourCards -> GHC.Types.False }
                   Hands.StraightFlush
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Hands.StraightFlush -> GHC.Types.False } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fEqPokerHand_$c== ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Hands.PokerHand) (ds1 :: Hands.PokerHand) ->
                 case ds of wild {
                   Hands.HighCards
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.HighCards -> GHC.Types.True }
                   Hands.OnePair
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.OnePair -> GHC.Types.True }
                   Hands.TwoPair
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.TwoPair -> GHC.Types.True }
                   Hands.ThreeCards
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.ThreeCards -> GHC.Types.True }
                   Hands.Straight
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.Straight -> GHC.Types.True }
                   Hands.Flush
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.Flush -> GHC.Types.True }
                   Hands.FullHouse
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.FullHouse -> GHC.Types.True }
                   Hands.FourCards
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Hands.FourCards -> GHC.Types.True }
                   Hands.StraightFlush
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Hands.StraightFlush -> GHC.Types.True } }) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand :: GHC.Classes.Ord Hands.Hand
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.Hand
                  Hands.$fEqHand
                  Hands.$fOrdHand_$ccompare
                  Hands.$fOrdHand_$c<
                  Hands.$fOrdHand_$c<=
                  Hands.$fOrdHand_$c>
                  Hands.$fOrdHand_$c>=
                  Hands.$fOrdHand_$cmax
                  Hands.$fOrdHand_$cmin -}
a0cd969de03d41e63f4b1e0fb4dd2322
  $fOrdHand1 :: [Cards.Card] -> [Cards.Card] -> [Cards.Card]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
fb6d441006ccc65ca38dfac5cc7f7917
  $fOrdHand2 :: [Cards.Card] -> [Cards.Card] -> [Cards.Card]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
e6113407f86888739d80529ac3ca5aaf
  $fOrdHand3 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
00b808c38d648311be793a9db8370b00
  $fOrdHand4 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
54ca0e8237a12bc1a30494b379896355
  $fOrdHand5 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
f1c6e22703d68d68b8ea37f0cf8f5445
  $fOrdHand6 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [Cards.Card]) (y :: [Cards.Card]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Cards.Card
                        Cards.$fOrdCard
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
9c52fb9a0d0d986af0f2f46790b38584
  $fOrdHand7 :: [Cards.Card] -> [Cards.Card] -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Classes.$fOrd[]_$ccompare
                   @ Cards.Card
                   Cards.$fOrdCard) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$c< :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand6
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$c<= :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand5
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$c> :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand4
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$c>= :: Hands.Hand -> Hands.Hand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand3
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Bool>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$ccompare ::
    Hands.Hand -> Hands.Hand -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand7
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R <GHC.Types.Ordering>_R) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$cmax :: Hands.Hand -> Hands.Hand -> Hands.Hand
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand2
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])) -}
36d64dbe2425fd68387689087fcb4672
  $fOrdHand_$cmin :: Hands.Hand -> Hands.Hand -> Hands.Hand
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fOrdHand1
                  `cast`
                (Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])
                 ->_R Sym (Hands.N:Hand[0])) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand :: GHC.Classes.Ord Hands.PokerHand
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.PokerHand
                  Hands.$fEqPokerHand
                  Hands.$fOrdPokerHand_$ccompare
                  Hands.$fOrdPokerHand_$c<
                  Hands.$fOrdPokerHand_$c<=
                  Hands.$fOrdPokerHand_$c>
                  Hands.$fOrdPokerHand_$c>=
                  Hands.$fOrdPokerHand_$cmax
                  Hands.$fOrdPokerHand_$cmin -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$c< ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$c<= ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$c> ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$c>= ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                      (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$ccompare ::
    Hands.PokerHand -> Hands.PokerHand -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Hands.PokerHand) (b :: Hands.PokerHand) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Hands.PokerHand x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$cmax ::
    Hands.PokerHand -> Hands.PokerHand -> Hands.PokerHand
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Hands.PokerHand) (y :: Hands.PokerHand) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                           (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fOrdPokerHand_$cmin ::
    Hands.PokerHand -> Hands.PokerHand -> Hands.PokerHand
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Hands.PokerHand) (y :: Hands.PokerHand) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Hands.PokerHand x1)
                           (GHC.Prim.dataToTag# @ Hands.PokerHand x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand :: GHC.Read.Read Hands.PokerHand
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.PokerHand
                  Hands.$fReadPokerHand_$creadsPrec
                  Hands.$fReadPokerHand_$creadList
                  Hands.$fReadPokerHand_$creadPrec
                  Hands.$fReadPokerHand_$creadListPrec -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Hands.PokerHand] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Hands.PokerHand] -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Hands.PokerHand
                   Hands.$fReadPokerHand2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Hands.PokerHand>_R))
                   @ b
                   eta1) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand19
                   Hands.$fReadPokerHand11) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand16
                   Hands.$fReadPokerHand12) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand13
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand15,
                  Hands.$fReadPokerHand14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.StraightFlush) -}
a6d98f26afb3f897b1402bf94c908fdc
  $fReadPokerHand15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "StraightFlush"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand16 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand18,
                  Hands.$fReadPokerHand17
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand17 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.FourCards) -}
aff09cf939f194c1987f0c3c7c4a4ef6
  $fReadPokerHand18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FourCards"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand19 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand21,
                  Hands.$fReadPokerHand20
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Hands.PokerHand
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Hands.PokerHand
                   Hands.$fReadPokerHand3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Hands.PokerHand>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Hands.PokerHand>_R)))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand20 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.FullHouse) -}
37d4134128aa377a9ce159c8af904409
  $fReadPokerHand21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FullHouse"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand22 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand24,
                  Hands.$fReadPokerHand23
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand23 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.Flush) -}
15711140d6ec19ee12d47e0d3ca94d1e
  $fReadPokerHand24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Flush"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand25 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand27,
                  Hands.$fReadPokerHand26
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand26 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.Straight) -}
fe082ba9bbeb558dbd613169164c2cca
  $fReadPokerHand27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Straight"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand28 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand30,
                  Hands.$fReadPokerHand29
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand29 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.ThreeCards) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Hands.PokerHand
                   Hands.$fReadPokerHand4
                   eta
                   @ b
                   eta1) -}
264bd292051bb00a8bce622bf33207c5
  $fReadPokerHand30 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ThreeCards"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand31 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand33,
                  Hands.$fReadPokerHand32
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand32 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.TwoPair) -}
47901c6c88969ebf77dcbbe20697d95c
  $fReadPokerHand33 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TwoPair"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand34 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand36,
                  Hands.$fReadPokerHand35
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand35 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.OnePair) -}
1ad55c9067006a9f65ab5dfd69229d40
  $fReadPokerHand36 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OnePair"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand37 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
  {- Strictness: m,
     Unfolding: ((Hands.$fReadPokerHand39,
                  Hands.$fReadPokerHand38
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Hands.PokerHand>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Hands.PokerHand>_R))))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand38 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Hands.PokerHand -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Hands.PokerHand -> Text.ParserCombinators.ReadP.P b) ->
                 eta Hands.HighCards) -}
52281a9509f7749681bddb7c5e20b82a
  $fReadPokerHand39 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HighCards"#) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand37
                   Hands.$fReadPokerHand5) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand40 ::
    Text.ParserCombinators.ReadP.P [Hands.PokerHand]
  {- Unfolding: (GHC.Read.$wlist
                   @ Hands.PokerHand
                   Hands.$fReadPokerHand2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Hands.PokerHand>_R))
                   @ [Hands.PokerHand]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Hands.PokerHand])) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand34
                   Hands.$fReadPokerHand6) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand31
                   Hands.$fReadPokerHand7) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand28
                   Hands.$fReadPokerHand8) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand25
                   Hands.$fReadPokerHand9) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand)
                   Hands.$fReadPokerHand22
                   Hands.$fReadPokerHand10) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Hands.PokerHand]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Hands.PokerHand]
                   Hands.$fReadPokerHand40) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Hands.PokerHand]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Hands.$fReadPokerHand1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Hands.PokerHand]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Hands.PokerHand]>_R))) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Hands.PokerHand
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Hands.$fReadPokerHand2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Hands.PokerHand>_R)) -}
809a7a18918542f71a6511a2ac0dbca3
  $fReadPokerHand_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Hands.PokerHand
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Hands.PokerHand
                   ((GHC.Read.$fReadDouble10
                       @ Hands.PokerHand
                       Hands.$fReadPokerHand3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Hands.PokerHand>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Hands.PokerHand>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Hands.PokerHand>_R)
                      @ Hands.PokerHand
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Hands.PokerHand))) -}
36d64dbe2425fd68387689087fcb4672
  $fShowHand :: GHC.Show.Show Hands.Hand
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.Hand
                  Hands.$fShowHand_$cshowsPrec
                  Hands.$fShowHand_$cshow
                  Hands.$fShowHand_$cshowList -}
36d64dbe2425fd68387689087fcb4672
  $fShowHand1 :: Hands.Hand -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Hands.Hand) (w1 :: GHC.Base.String) ->
                 Hands.$w$cshowsPrec 0# w w1) -}
b254f85e659af1adb1e5262118d96007
  $fShowHand2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
c4e75f2bf028b97608b151698cac2e37
  $fShowHand3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fromHand = "#) -}
66aa08ff31f467f8a575fd1e4f5abfdc
  $fShowHand4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hand {"#) -}
36d64dbe2425fd68387689087fcb4672
  $fShowHand_$cshow :: Hands.Hand -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Hands.Hand) ->
                 Hands.$fShowHand_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
36d64dbe2425fd68387689087fcb4672
  $fShowHand_$cshowList :: [Hands.Hand] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Hands.Hand Hands.$fShowHand1) -}
36d64dbe2425fd68387689087fcb4672
  $fShowHand_$cshowsPrec ::
    GHC.Types.Int -> Hands.Hand -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Hands.Hand)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Hands.$w$cshowsPrec ww1 w1 w2 }) -}
809a7a18918542f71a6511a2ac0dbca3
  $fShowPokerHand :: GHC.Show.Show Hands.PokerHand
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Hands.PokerHand
                  Hands.$fShowPokerHand_$cshowsPrec
                  Hands.$fShowPokerHand_$cshow
                  Hands.$fShowPokerHand_$cshowList -}
809a7a18918542f71a6511a2ac0dbca3
  $fShowPokerHand_$cshow :: Hands.PokerHand -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Hands.PokerHand) ->
                 Hands.$fShowPokerHand_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
809a7a18918542f71a6511a2ac0dbca3
  $fShowPokerHand_$cshowList :: [Hands.PokerHand] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Hands.PokerHand
                   Hands.$w$cshowsPrec1) -}
809a7a18918542f71a6511a2ac0dbca3
  $fShowPokerHand_$cshowsPrec ::
    GHC.Types.Int -> Hands.PokerHand -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Hands.PokerHand)
                   (w2 :: GHC.Base.String) ->
                 Hands.$w$cshowsPrec1 w1 w2) -}
72a9134b13ce325efd9fba7c69ca7d8c
  $s$fEq[] :: GHC.Classes.Eq [Cards.Card]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [Cards.Card]
                  (GHC.Classes.$fEq[]_$c== @ Cards.Card Cards.$fEqCard)
                  Hands.$fEqHand_$s$fEq[]_$c/= -}
ab70ca782bf23ce0d59590ee7455e7ff
  $smaximum1 :: Cards.Card
  {- Strictness: x -}
bb4a1a1bae96c99a0d9dede4e5237bd4
  $tc'Flush :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8144211653255830965##
                   12857877332980508569##
                   Hands.$trModule
                   Hands.$tc'Flush1) -}
cc6104152b0b02a9ecc1f639de07cd36
  $tc'Flush1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Flush"#) -}
774bec64689abe551aea3fe505821710
  $tc'FourCards :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9077495177665053533##
                   10286656685950972130##
                   Hands.$trModule
                   Hands.$tc'FourCards1) -}
8d324560f98fcc3d12f837026ca01179
  $tc'FourCards1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FourCards"#) -}
6a87a787508bdeddae8b5c00e57d504a
  $tc'FullHouse :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6749534535460001104##
                   14673036281578832257##
                   Hands.$trModule
                   Hands.$tc'FullHouse1) -}
ca608a03472f821c00274f65e87dfd8f
  $tc'FullHouse1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FullHouse"#) -}
8c39d71dcdad346cd82b074cc4a331ce
  $tc'Hand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8483065848114099223##
                   2866858566654975822##
                   Hands.$trModule
                   Hands.$tc'Hand1) -}
4d2e36344d26a4045919dfc6170e15b2
  $tc'Hand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Hand"#) -}
b231fb9544622dbb0d994e3b2bb7d071
  $tc'HighCards :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4688155198566778293##
                   8339758238868257414##
                   Hands.$trModule
                   Hands.$tc'HighCards1) -}
107a21281e5f3623dc55382a98107065
  $tc'HighCards1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HighCards"#) -}
ecd32e8bc3c344824072aface633b9cd
  $tc'OnePair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   850828269213790789##
                   8071454478357133394##
                   Hands.$trModule
                   Hands.$tc'OnePair1) -}
e74ea5072e168a2adc9ed3a862a153cb
  $tc'OnePair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OnePair"#) -}
db5c7c20367d1405f79b0dad65b65288
  $tc'Straight :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14949213868872112782##
                   10850611491571199074##
                   Hands.$trModule
                   Hands.$tc'Straight1) -}
0a8594265208d9dc981f1e79dd2a753f
  $tc'Straight1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Straight"#) -}
552bad1f3cbf5fd562f847e3a40291c8
  $tc'StraightFlush :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9178353376044261533##
                   177971332692350859##
                   Hands.$trModule
                   Hands.$tc'StraightFlush1) -}
7ad96f31f64581e8c2572aba973e7443
  $tc'StraightFlush1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'StraightFlush"#) -}
6978c32ccaa57ec9dbe84058e4625db8
  $tc'ThreeCards :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1524939742823661903##
                   8017926611477842279##
                   Hands.$trModule
                   Hands.$tc'ThreeCards1) -}
3ed6cb44ffd50399dbe264ae897801f7
  $tc'ThreeCards1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ThreeCards"#) -}
6048184812a48055280ede2fefa2e27c
  $tc'TwoPair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17222157270510200115##
                   17069216405736032878##
                   Hands.$trModule
                   Hands.$tc'TwoPair1) -}
fb66c6387e0449d8b56fc73406f35a3c
  $tc'TwoPair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TwoPair"#) -}
3711de88d312e7144233adbac4221104
  $tcHand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10858027150854297569##
                   6620373383070445602##
                   Hands.$trModule
                   Hands.$tcHand1) -}
34d629297821f9a53ab482df563ae661
  $tcHand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Hand"#) -}
c6e073ffd3064f75cf1aaed8acfb5cab
  $tcPokerHand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17835943703432084685##
                   1717810778144277720##
                   Hands.$trModule
                   Hands.$tcPokerHand1) -}
34f8085aac3efbb69016982a9193ac85
  $tcPokerHand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PokerHand"#) -}
b42819c31bcc97c1d4ce5f33f51c7008
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Hands.$trModule2 Hands.$trModule1) -}
8394512708dd40666c6436cf8a1438b5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Hands"#) -}
df5d70e9347d9d257d3d910e1d1bf540
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
36d64dbe2425fd68387689087fcb4672
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Hands.Hand -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Hands.Hand)
                   (w1 :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Hands.$fShowHand4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Hands.$fShowHand3
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char Hands.$fShowHand2 x
                           } in
                           case w `cast` (Hands.N:Hand[0]) of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__2
                                  (case x1 of ww1 { Cards.Card ww2 ww3 ->
                                   Cards.$w$cshowsPrec
                                     ww2
                                     ww3
                                     (let {
                                        lvl27 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__1 s
                                      } in
                                      letrec {
                                        showl :: [Cards.Card] -> GHC.Base.String
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ (ds2 :: [Cards.Card]) ->
                                          case ds2 of wild1 {
                                            [] -> lvl27
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows7
                                                 (case y of ww4 { Cards.Card ww5 ww6 ->
                                                  Cards.$w$cshowsPrec ww5 ww6 (showl ys) }) }
                                      } in
                                      showl xs) }) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w1
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)) }) -}
809a7a18918542f71a6511a2ac0dbca3
  $w$cshowsPrec1 ::
    Hands.PokerHand -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Hands.PokerHand) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Hands.HighCards
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand39 w1
                   Hands.OnePair
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand36 w1
                   Hands.TwoPair
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand33 w1
                   Hands.ThreeCards
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand30 w1
                   Hands.Straight
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand27 w1
                   Hands.Flush
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand24 w1
                   Hands.FullHouse
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand21 w1
                   Hands.FourCards
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand18 w1
                   Hands.StraightFlush
                   -> GHC.Base.++ @ GHC.Types.Char Hands.$fReadPokerHand15 w1 }) -}
809a7a18918542f71a6511a2ac0dbca3
  $w$ctoEnum :: GHC.Prim.Int# -> Hands.PokerHand
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Hands.$fEnumPokerHand1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 8#) of wild1 {
                        GHC.Types.False -> Hands.$fEnumPokerHand1 ww
                        GHC.Types.True -> GHC.Prim.tagToEnum# @ Hands.PokerHand ww } }) -}
1db7ea66a6e15eb47f7b86bba0abb810
  $wgo ::
    [Cards.Card]
    -> GHC.Types.Int -> Cards.Rank -> (# GHC.Types.Int, Cards.Rank #)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U(U)><L,U>,
     Inline: [0] -}
90319c9776f0383d4c3c874a00e2a471
  $wpokerHand :: Hands.Hand -> (# Hands.PokerHand, Cards.Card #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
36d64dbe2425fd68387689087fcb4672
  newtype Hand = Hand {fromHand :: [Cards.Card]}
809a7a18918542f71a6511a2ac0dbca3
  data PokerHand
    = HighCards
    | OnePair
    | TwoPair
    | ThreeCards
    | Straight
    | Flush
    | FullHouse
    | FourCards
    | StraightFlush
9682287d6f7f6f56f624046907df8a39
  fromHand :: Hands.Hand -> [Cards.Card]
  RecSel Left Hands.Hand
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Hands.fromHand1 `cast` (<Hands.Hand>_R ->_R Hands.N:Hand[0]) -}
657fce8dfb542dbbe8d0b37b94ba3cec
  fromHand1 :: Hands.Hand -> Hands.Hand
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Hands.Hand) -> ds) -}
19c8692a2fbdfff1d80560ff19e6da2f
  pokerHand :: Hands.Hand -> (Hands.PokerHand, Cards.Card)
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Hands.Hand) ->
                 case Hands.$wpokerHand w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
e4833d5e78da867e177675099c243f67
  toHand :: [Cards.Card] -> GHC.Base.Maybe Hands.Hand
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (l :: [Cards.Card]) ->
                 case GHC.List.$wlenAcc @ Cards.Card l 0# of ww2 {
                   DEFAULT -> GHC.Base.Nothing @ Hands.Hand
                   5#
                   -> GHC.Base.Just
                        @ Hands.Hand
                        (Data.OldList.sortBy @ Cards.Card Cards.$fOrdCard_$ccompare l)
                          `cast`
                        (Sym (Hands.N:Hand[0])) }) -}
instance GHC.Enum.Enum [Hands.PokerHand] = Hands.$fEnumPokerHand
instance GHC.Classes.Eq [Hands.Hand] = Hands.$fEqHand
instance GHC.Classes.Eq [Hands.PokerHand] = Hands.$fEqPokerHand
instance GHC.Classes.Ord [Hands.Hand] = Hands.$fOrdHand
instance GHC.Classes.Ord [Hands.PokerHand] = Hands.$fOrdPokerHand
instance GHC.Read.Read [Hands.PokerHand] = Hands.$fReadPokerHand
instance GHC.Show.Show [Hands.Hand] = Hands.$fShowHand
instance GHC.Show.Show [Hands.PokerHand] = Hands.$fShowPokerHand
"SPEC/Hands $fEq[] @ Card" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Cards.Card)
  GHC.Classes.$fEq[] @ Cards.Card $dEq = Hands.$s$fEq[]
"SPEC/Hands $fEq[]_$c/= @ Card" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                           Cards.Card)
  GHC.Classes.$fEq[]_$c/= @ Cards.Card $dEq
  = Hands.$fEqHand_$s$fEq[]_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

